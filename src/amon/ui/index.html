<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Amon｜Chat UI</title>
    <link rel="stylesheet" href="styles.css" />
    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
      mermaid.initialize({ startOnLoad: false, theme: "neutral" });
      window.__mermaid = mermaid;
    </script>
  </head>
  <body>
    <main class="page">
      <div class="ui-shell" id="ui-shell">
        <aside class="shell-sidebar" aria-label="主要導覽">
          <h2>Amon UI</h2>
          <nav class="shell-nav">
            <button type="button" class="shell-nav__item is-active">Chat</button>
            <button type="button" class="shell-nav__item">Context</button>
            <button type="button" class="shell-nav__item">Graph</button>
            <button type="button" class="shell-nav__item">Tools &amp; Skills</button>
            <button type="button" class="shell-nav__item">Config</button>
            <button type="button" class="shell-nav__item">Logs &amp; Events</button>
            <button type="button" class="shell-nav__item">Docs</button>
            <button type="button" class="shell-nav__item">Bill</button>
          </nav>
        </aside>

        <section class="shell-main">
          <header class="shell-topbar" aria-label="工作列">
            <div class="shell-topbar__group">
              <label class="field-label shell-topbar__field">
                Project
                <select id="shell-project-select">
                  <option>Demo 專案（假資料）</option>
                  <option>Internal Playground（假資料）</option>
                </select>
              </label>
              <span class="shell-status shell-status--run">Run：Idle</span>
              <span class="shell-status shell-status--daemon">Daemon：Healthy</span>
              <span class="shell-status shell-status--budget">Budget：NT$ 0 / NT$ 5,000</span>
            </div>
            <button type="button" class="secondary-btn shell-context-toggle" id="toggle-context-panel" aria-expanded="true">收合右側面板</button>
          </header>

          <div class="layout chat-layout" id="chat-layout">
            <section class="main-card chat-panel">
          <header class="chat-header">
            <div>
              <h1>Amon Chat</h1>
              <p class="subtitle">請用自然語言操作專案與任務（支援 streaming）。</p>
            </div>
            <div class="chat-controls">
              <label class="field-label">
                專案
                <select id="project-select"></select>
              </label>
              <button class="secondary-btn" id="refresh-context">刷新 Context</button>
            </div>
          </header>

          <section id="timeline" class="chat-timeline"></section>

          <section class="thinking-panel" id="thinking-panel">
            <div class="thinking-panel__header">
              <h3>Thinking 狀態</h3>
              <label class="field-label thinking-mode">
                顯示模式
                <select id="thinking-mode">
                  <option value="off">off</option>
                  <option value="brief" selected>brief</option>
                  <option value="verbose">verbose</option>
                </select>
              </label>
            </div>
            <details open id="thinking-details">
              <summary id="thinking-summary">目前沒有 Thinking 事件</summary>
              <div id="thinking-detail" class="thinking-panel__detail"></div>
            </details>
          </section>

          <div class="progress-bar" id="stream-progress" aria-hidden="true">
            <span></span>
          </div>

          <section id="plan-card" class="plan-card" hidden>
            <div class="plan-card__header">
              <h3>Plan Card</h3>
              <p>此操作需要確認才能繼續。</p>
            </div>
            <div class="plan-grid">
              <div>
                <h4>Commands</h4>
                <ul id="plan-commands" class="plan-list"></ul>
              </div>
              <div>
                <h4>Graph Patches</h4>
                <ul id="plan-patches" class="plan-list"></ul>
              </div>
            </div>
            <div class="plan-risk" id="plan-risk"></div>
            <pre id="plan-content"></pre>
            <div class="plan-card__actions">
              <button class="secondary-btn" id="plan-cancel">取消</button>
              <button class="primary-btn" id="plan-confirm">確認執行</button>
            </div>
          </section>

          <section class="artifact-section">
            <div class="artifact-section__header">
              <h3>Artifacts</h3>
              <p>顯示來自 run/node 的產出。</p>
            </div>
            <div id="artifact-list" class="artifact-list"></div>
          </section>

          <form id="chat-form" class="chat-input">
            <div class="chat-input__main">
              <textarea id="chat-input" rows="4" placeholder="輸入你的需求，例如：建立專案 Amon Demo"></textarea>
              <div class="chat-input__toolbar">
                <label class="file-btn">
                  加入附件
                  <input id="chat-attachments" type="file" multiple accept="image/*,video/*,.pdf" />
                </label>
                <span class="chat-input__hint">支援圖片、PDF、影片；附件會以文字摘要送出。</span>
              </div>
              <div id="attachment-preview" class="attachment-preview"></div>
            </div>
            <button type="submit" class="primary-btn">送出</button>
          </form>
        </section>

            <aside class="context-panel" id="context-panel">
          <h2>右側資訊</h2>
          <div class="context-shell-placeholders" aria-label="右側狀態摘要">
            <div class="context-shell-card">
              <p class="context-shell-card__label">Memory Used</p>
              <strong>--</strong>
            </div>
            <div class="context-shell-card">
              <p class="context-shell-card__label">Run Progress</p>
              <strong>--</strong>
            </div>
            <div class="context-shell-card">
              <p class="context-shell-card__label">Billing</p>
              <strong>--</strong>
            </div>
            <div class="context-shell-card">
              <p class="context-shell-card__label">Pending Confirmations</p>
              <strong>--</strong>
            </div>
          </div>
          <div class="context-project" id="context-project">目前專案：未選擇</div>
          <div class="context-tabs" role="tablist" aria-label="右側資訊切換">
            <button type="button" class="context-tab is-active" data-context-tab="context" role="tab" aria-selected="true">Context</button>
            <button type="button" class="context-tab" data-context-tab="graph" role="tab" aria-selected="false">Graph</button>
            <button type="button" class="context-tab" data-context-tab="docs" role="tab" aria-selected="false">Docs</button>
          </div>

          <section class="context-section" data-context-panel="context">
            <h3>Context</h3>
            <p id="context-overview" class="context-overview">請先在上方選擇專案，右側內容會自動同步。</p>
          </section>
          <section class="context-section" data-context-panel="graph" hidden>
            <h3>Graph Preview</h3>
            <div id="graph-preview" class="graph-preview"></div>
            <pre id="graph-code" class="graph-code"></pre>
          </section>
          <section class="context-section" data-context-panel="docs" hidden>
            <h3>Docs</h3>
            <ul id="docs-list" class="docs-list"></ul>
          </section>
            </aside>
          </div>
        </section>
      </div>
    </main>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <script>
      const state = {
        chatId: null,
        projectId: null,
        plan: null,
        streaming: false,
        attachments: [],
        mockMode: true,
        thinkingMode: "brief",
        pendingAssistantBubble: null,
      };

      const elements = {
        projectSelect: document.getElementById("project-select"),
        timeline: document.getElementById("timeline"),
        chatForm: document.getElementById("chat-form"),
        chatInput: document.getElementById("chat-input"),
        chatAttachments: document.getElementById("chat-attachments"),
        attachmentPreview: document.getElementById("attachment-preview"),
        toast: document.getElementById("toast"),
        planCard: document.getElementById("plan-card"),
        planContent: document.getElementById("plan-content"),
        planCommands: document.getElementById("plan-commands"),
        planPatches: document.getElementById("plan-patches"),
        planRisk: document.getElementById("plan-risk"),
        planConfirm: document.getElementById("plan-confirm"),
        planCancel: document.getElementById("plan-cancel"),
        refreshContext: document.getElementById("refresh-context"),
        graphPreview: document.getElementById("graph-preview"),
        graphCode: document.getElementById("graph-code"),
        docsList: document.getElementById("docs-list"),
        contextProject: document.getElementById("context-project"),
        contextOverview: document.getElementById("context-overview"),
        contextTabs: document.querySelectorAll(".context-tab"),
        contextPanels: document.querySelectorAll("[data-context-panel]"),
        streamProgress: document.getElementById("stream-progress"),
        uiShell: document.getElementById("ui-shell"),
        toggleContextPanel: document.getElementById("toggle-context-panel"),
        thinkingMode: document.getElementById("thinking-mode"),
        thinkingSummary: document.getElementById("thinking-summary"),
        thinkingDetail: document.getElementById("thinking-detail"),
        artifactList: document.getElementById("artifact-list"),
      };

      function syncContextPanelToggle() {
        if (!elements.uiShell || !elements.toggleContextPanel) {
          return;
        }
        const collapsed = elements.uiShell.classList.contains("is-context-collapsed");
        elements.toggleContextPanel.textContent = collapsed ? "展開右側面板" : "收合右側面板";
        elements.toggleContextPanel.setAttribute("aria-expanded", String(!collapsed));
      }

      elements.toggleContextPanel?.addEventListener("click", () => {
        elements.uiShell?.classList.toggle("is-context-collapsed");
        syncContextPanelToggle();
      });

      syncContextPanelToggle();

      function showToast(message) {
        elements.toast.textContent = message;
        elements.toast.classList.add("visible");
        window.clearTimeout(elements.toast._timer);
        elements.toast._timer = window.setTimeout(() => {
          elements.toast.classList.remove("visible");
        }, 9000);
      }

      async function apiFetch(path, options = {}) {
        const response = await fetch(`/v1${path}`, {
          headers: { "Content-Type": "application/json" },
          ...options,
        });
        let payload = {};
        try {
          payload = await response.json();
        } catch (error) {
          payload = {};
        }
        if (!response.ok) {
          throw new Error(payload.message || "API 發生錯誤");
        }
        return payload;
      }

      function appendMessage(role, text, meta = {}) {
        const row = document.createElement("article");
        row.className = "timeline-row";

        const bubble = document.createElement("div");
        bubble.className = `chat-bubble ${role}`;
        bubble.innerHTML = renderMarkdown(text);

        const footer = document.createElement("footer");
        footer.className = "timeline-meta";
        const roleLabel = role === "user" ? "你" : "Amon";
        const status = meta.status ? `・${meta.status}` : "";
        footer.textContent = `${new Date().toLocaleTimeString("zh-TW", { hour12: false })}・${roleLabel}${status}`;

        row.appendChild(bubble);
        row.appendChild(footer);
        elements.timeline.appendChild(row);
        elements.timeline.scrollTop = elements.timeline.scrollHeight;
        return bubble;
      }

      function appendTimelineStatus(message) {
        const item = document.createElement("div");
        item.className = "timeline-status";
        item.textContent = message;
        elements.timeline.appendChild(item);
        elements.timeline.scrollTop = elements.timeline.scrollHeight;
      }

      function escapeHtml(text) {
        return text
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function renderInlineMarkdown(text) {
        let html = escapeHtml(text);
        html = html.replace(/`([^`]+)`/g, "<code>$1</code>");
        html = html.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        html = html.replace(/\*([^*]+)\*/g, "<em>$1</em>");
        html = html.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
        return html;
      }

      function renderMarkdown(text) {
        const lines = String(text || "").split("\n");
        const html = [];
        let inList = false;
        let inCodeBlock = false;
        let codeLines = [];
        let paragraph = [];

        const flushParagraph = () => {
          if (!paragraph.length) return;
          html.push(`<p>${renderInlineMarkdown(paragraph.join("\n")).replaceAll("\n", "<br />")}</p>`);
          paragraph = [];
        };

        const flushCodeBlock = () => {
          if (!inCodeBlock) return;
          html.push(`<pre><code>${escapeHtml(codeLines.join("\n"))}</code></pre>`);
          inCodeBlock = false;
          codeLines = [];
        };

        const closeList = () => {
          if (!inList) return;
          html.push("</ul>");
          inList = false;
        };

        lines.forEach((rawLine) => {
          const line = rawLine.trimEnd();
          if (line.trim().startsWith("```")) {
            flushParagraph();
            closeList();
            if (inCodeBlock) {
              flushCodeBlock();
            } else {
              inCodeBlock = true;
              codeLines = [];
            }
            return;
          }

          if (inCodeBlock) {
            codeLines.push(rawLine);
            return;
          }

          if (!line.trim()) {
            flushParagraph();
            closeList();
            return;
          }

          const headingMatch = line.match(/^(#{1,3})\s+(.+)$/);
          if (headingMatch) {
            flushParagraph();
            closeList();
            const level = headingMatch[1].length;
            html.push(`<h${level}>${renderInlineMarkdown(headingMatch[2])}</h${level}>`);
            return;
          }

          const listMatch = line.match(/^[-*]\s+(.+)$/);
          if (listMatch) {
            flushParagraph();
            if (!inList) {
              html.push("<ul>");
              inList = true;
            }
            html.push(`<li>${renderInlineMarkdown(listMatch[1])}</li>`);
            return;
          }

          closeList();
          paragraph.push(line);
        });

        flushParagraph();
        closeList();
        flushCodeBlock();
        return html.join("");
      }

      function setStreaming(active) {
        state.streaming = active;
        elements.streamProgress.hidden = !active;
        elements.chatInput.disabled = active;
      }

      function resetPlanCard() {
        state.plan = null;
        elements.planCard.hidden = true;
        elements.planContent.textContent = "";
        elements.planCommands.innerHTML = "";
        elements.planPatches.innerHTML = "";
        elements.planRisk.innerHTML = "";
      }

      function setProjectState(projectId) {
        state.projectId = projectId || null;
        elements.refreshContext.disabled = !state.projectId;
        elements.projectSelect.value = projectId || "";
        syncContextHeader();
        if (!state.projectId) {
          state.chatId = null;
          elements.graphPreview.innerHTML = "<p class=\"empty-context\">請先在上方選擇專案。</p>";
          elements.graphCode.textContent = "";
          elements.contextOverview.textContent = "請先在上方選擇專案，右側內容會自動同步。";
          renderDocs([]);
        }
      }

      function syncContextHeader() {
        const selected = elements.projectSelect.selectedOptions[0]?.textContent || "未選擇";
        elements.contextProject.textContent = `目前專案：${selected}`;
      }

      function switchContextTab(tabName) {
        elements.contextTabs.forEach((tab) => {
          const isActive = tab.dataset.contextTab === tabName;
          tab.classList.toggle("is-active", isActive);
          tab.setAttribute("aria-selected", String(isActive));
        });
        elements.contextPanels.forEach((panel) => {
          panel.hidden = panel.dataset.contextPanel !== tabName;
        });
      }

      async function loadProjects() {
        let projects = [];
        try {
          const payload = await apiFetch("/projects");
          projects = payload.projects || [];
        } catch (error) {
          if (!state.mockMode) {
            throw error;
          }
          projects = [
            { project_id: "demo-project", name: "Demo 專案（Mock）" },
            { project_id: "playground", name: "Internal Playground（Mock）" },
          ];
        }
        elements.projectSelect.innerHTML = "";
        const emptyOption = document.createElement("option");
        emptyOption.value = "";
        emptyOption.textContent = "不指定專案";
        elements.projectSelect.appendChild(emptyOption);
        projects.forEach((project) => {
          const option = document.createElement("option");
          option.value = project.project_id;
          option.textContent = `${project.name}（${project.project_id}）`;
          elements.projectSelect.appendChild(option);
        });
        const availableIds = new Set(projects.map((project) => project.project_id));
        if (state.projectId && !availableIds.has(state.projectId)) {
          state.projectId = null;
        }
        if (!state.projectId && state.mockMode && projects.length) {
          state.projectId = projects[0].project_id;
        }
        elements.projectSelect.value = state.projectId || "";
        syncContextHeader();
        if (!projects.length) {
          showToast("尚無專案，請在聊天輸入：建立專案 <名稱>");
        }
        elements.refreshContext.disabled = !state.projectId;
      }

      async function ensureChatSession() {
        if (!state.projectId) return;
        if (state.mockMode) {
          state.chatId = state.chatId || `mock-chat-${state.projectId}`;
          return;
        }
        const payload = await apiFetch("/chat/sessions", {
          method: "POST",
          body: JSON.stringify({ project_id: state.projectId }),
        });
        state.chatId = payload.chat_id;
      }

      async function loadContext() {
        if (!state.projectId) {
          showToast("請先選擇專案。");
          return;
        }
        let payload;
        if (state.mockMode) {
          payload = {
            graph_mermaid: `graph TD
User-->Chat
Chat-->Planner
Planner-->Artifacts`,
            docs: ["docs/overview.md", "docs/roadmap.md"],
          };
        } else {
          payload = await apiFetch(`/projects/${state.projectId}/context`);
        }
        elements.graphCode.textContent = payload.graph_mermaid || "";
        renderMermaid(payload.graph_mermaid || "");
        renderDocs(payload.docs || []);
        const docCount = (payload.docs || []).length;
        const hasGraph = payload.graph_mermaid ? "有" : "無";
        elements.contextOverview.textContent = `已同步專案內容：Graph ${hasGraph}、文件 ${docCount} 筆。`;
      }

      function renderDocs(docs) {
        elements.docsList.innerHTML = "";
        if (!docs.length) {
          const item = document.createElement("li");
          item.textContent = state.projectId ? "尚無文件" : "請先選擇專案";
          elements.docsList.appendChild(item);
          return;
        }
        docs.forEach((doc) => {
          const item = document.createElement("li");
          item.textContent = doc;
          elements.docsList.appendChild(item);
        });
      }

      async function renderMermaid(code) {
        elements.graphPreview.innerHTML = "";
        if (!code) return;
        try {
          const { svg } = await window.__mermaid.render("graphPreview", code);
          elements.graphPreview.innerHTML = svg;
        } catch (error) {
          elements.graphPreview.innerHTML = "<p>Mermaid 渲染失敗，請檢查 graph。</p>";
        }
      }

      function renderPlanList(target, rows = []) {
        target.innerHTML = "";
        if (!rows.length) {
          const empty = document.createElement("li");
          empty.textContent = "無";
          target.appendChild(empty);
          return;
        }
        rows.forEach((row) => {
          const item = document.createElement("li");
          item.textContent = typeof row === "string" ? row : JSON.stringify(row);
          target.appendChild(item);
        });
      }

      function renderPlanRisk(plan) {
        const risk = plan.risk || {};
        const chips = [
          `require_confirm：${risk.require_confirm ? "是" : "否"}`,
          `file change plan：${risk.file_change_plan || "未提供"}`,
          `cost：${risk.cost || "未知"}`,
        ];
        elements.planRisk.innerHTML = chips.map((chip) => `<span class="risk-chip">${chip}</span>`).join("");
      }

      function showPlanCard(plan) {
        state.plan = plan;
        elements.planContent.textContent = plan.plan_card || "";
        renderPlanList(elements.planCommands, plan.commands || []);
        renderPlanList(elements.planPatches, plan.graph_patches || []);
        renderPlanRisk(plan);
        elements.planCard.hidden = false;
      }

      function applySessionFromEvent(data) {
        if (!data) return;
        if (data.project_id && data.project_id !== state.projectId) {
          setProjectState(data.project_id);
        }
        if (data.chat_id) {
          state.chatId = data.chat_id;
        }
      }

      async function confirmPlan(confirmed) {
        if (!state.plan) return;
        try {
          if (state.mockMode) {
            await new Promise((resolve) => window.setTimeout(resolve, 320));
          } else {
            await apiFetch("/chat/plan/confirm", {
              method: "POST",
              body: JSON.stringify({
                project_id: state.projectId,
                chat_id: state.chatId,
                command: state.plan.command,
                args: state.plan.args || {},
                confirmed,
              }),
            });
          }
          appendMessage("agent", confirmed ? "已確認執行，任務繼續。" : "已取消執行。", { status: "done" });
          showToast(state.mockMode ? "目前為 Mock API：已模擬 Plan Confirm。" : "Plan Confirm 成功。");
          resetPlanCard();
        } catch (error) {
          showToast(`Plan 執行失敗：${error.message}`);
        }
      }

      function buildAttachmentSummary(attachments) {
        if (!attachments || attachments.length === 0) return "";
        const lines = attachments.map((file) => {
          const sizeKb = Math.round(file.size / 1024);
          return `- ${file.name} (${file.type || "未知格式"}, ${sizeKb} KB)`;
        });
        return `\n\n[附件摘要]\n${lines.join("\n")}`;
      }

      function updateThinking(payload = {}) {
        const mode = state.thinkingMode;
        if (mode === "off") {
          elements.thinkingSummary.textContent = "Thinking 顯示已關閉";
          elements.thinkingDetail.textContent = "";
          return;
        }
        const status = payload.status || "分析中";
        const brief = payload.brief || "正在整理回覆與執行計畫";
        elements.thinkingSummary.textContent = `狀態：${status}｜${brief}`;
        elements.thinkingDetail.textContent = mode === "verbose" ? (payload.verbose || brief) : brief;
      }

      function renderArtifacts(artifacts = []) {
        elements.artifactList.innerHTML = "";
        if (!artifacts.length) {
          elements.artifactList.innerHTML = '<p class="empty-context">目前尚無 artifact</p>';
          return;
        }
        artifacts.forEach((artifact) => {
          const card = document.createElement("article");
          card.className = "artifact-card";
          card.innerHTML = `
            <header>
              <strong>${artifact.type}</strong>
              <span>${artifact.run_id}/${artifact.node_id}</span>
            </header>
            <p>${artifact.path}</p>
            <pre>${escapeHtml(artifact.preview || "(無預覽)")}</pre>
            <div class="artifact-card__actions">
              <button type="button" class="secondary-btn small" data-artifact-action="open">Open</button>
              <button type="button" class="secondary-btn small" data-artifact-action="download">Download</button>
              <button type="button" class="secondary-btn small" data-artifact-action="pin">Pin（stub）</button>
            </div>`;
          card.querySelectorAll("[data-artifact-action]").forEach((btn) => {
            btn.addEventListener("click", () => {
              showToast(`目前為 Mock 動作：${btn.dataset.artifactAction} ${artifact.path}`);
            });
          });
          elements.artifactList.appendChild(card);
        });
      }

      function applyTokenChunk(text = "") {
        if (!state.pendingAssistantBubble) {
          state.pendingAssistantBubble = appendMessage("agent", "Amon：", { status: "streaming" });
          state.pendingAssistantBubble.dataset.buffer = "";
        }
        state.pendingAssistantBubble.dataset.buffer = `${state.pendingAssistantBubble.dataset.buffer || ""}${text}`;
        state.pendingAssistantBubble.innerHTML = renderMarkdown(`Amon：${state.pendingAssistantBubble.dataset.buffer}`);
        elements.timeline.scrollTop = elements.timeline.scrollHeight;
      }

      function finalizeAssistantBubble() {
        state.pendingAssistantBubble = null;
      }

      function buildMockEventQueue() {
        return [
          { type: "thinking", data: { status: "planning", brief: "解析需求與附件摘要", verbose: "正在比對專案上下文與可執行工具，建立最低風險計畫。" } },
          { type: "token", data: { text: "我已收到需求，先建立可確認的執行計畫。" } },
          { type: "token", data: { text: "接著會等待你確認 Plan Card。" } },
          {
            type: "plan",
            data: {
              plan_card: "準備更新 chat timeline、thinking 區塊與 artifact cards。",
              commands: ["python -m unittest discover -s tests", "python -m compileall src tests"],
              graph_patches: ["+ node: artifact_renderer", "~ edge: stream -> timeline"],
              risk: { require_confirm: true, file_change_plan: "更新前端 HTML/CSS", cost: "low" },
              command: "apply_chat_ui_core",
              args: { target: "chat" },
            },
          },
          {
            type: "result",
            data: {
              artifacts: [
                { type: "doc", run_id: "run_demo_001", node_id: "summarizer", path: "docs/plan.md", preview: "# Plan\n- timeline streaming" },
                { type: "graph", run_id: "run_demo_001", node_id: "graph_builder", path: "graphs/flow.mmd", preview: "graph TD\nA-->B" },
                { type: "table", run_id: "run_demo_001", node_id: "metrics", path: "reports/summary.csv", preview: "name,value\nlatency,120" },
                { type: "log", run_id: "run_demo_001", node_id: "executor", path: "logs/run.log", preview: "INFO task finished" },
              ],
            },
          },
          { type: "done", data: { status: "completed" } },
        ];
      }

      function consumeEvent(eventType, data) {
        if (eventType === "token") {
          applyTokenChunk(data.text || "");
        } else if (eventType === "thinking") {
          updateThinking(data);
        } else if (eventType === "plan") {
          applySessionFromEvent(data);
          showPlanCard(data);
          appendTimelineStatus("已收到 Plan Card，請確認後繼續。");
        } else if (eventType === "result") {
          if (Array.isArray(data.artifacts)) {
            renderArtifacts(data.artifacts);
          }
          appendMessage("agent", `Amon：\n\n\`\`\`json\n${JSON.stringify(data, null, 2)}\n\`\`\``);
        } else if (eventType === "error") {
          showToast(data.message || "串流失敗");
        }
      }

      function runMockStream() {
        const queue = buildMockEventQueue();
        let index = 0;
        const next = () => {
          if (index >= queue.length) return;
          const event = queue[index++];
          if (event.type === "done") {
            finalizeAssistantBubble();
            setStreaming(false);
            appendTimelineStatus("Mock 串流完成。提醒：目前畫面使用 Mock data / Mock API。");
            return;
          }
          consumeEvent(event.type, event.data);
          window.setTimeout(next, event.type === "token" ? 260 : 420);
        };
        next();
      }

      function startStream(message, attachments = []) {
        resetPlanCard();
        const finalMessage = `${message}${buildAttachmentSummary(attachments)}`;
        appendMessage("user", `你：${finalMessage}`);
        appendTimelineStatus("訊息已送出，等待事件回傳中...");
        updateThinking({ status: "queued", brief: "已送出，等待伺服器事件" });
        setStreaming(true);

        if (state.mockMode) {
          showToast("提醒：目前為 Mock 串流與 Mock API，僅供 UI Demo。");
          runMockStream();
          return;
        }

        const query = new URLSearchParams({ message: finalMessage });
        if (state.projectId) {
          query.set("project_id", state.projectId);
        }
        if (state.chatId) {
          query.set("chat_id", state.chatId);
        }
        const source = new EventSource(`/v1/chat/stream?${query.toString()}`);

        source.addEventListener("token", (event) => {
          consumeEvent("token", JSON.parse(event.data || "{}"));
        });

        source.addEventListener("thinking", (event) => {
          consumeEvent("thinking", JSON.parse(event.data || "{}"));
        });

        source.addEventListener("plan", (event) => {
          consumeEvent("plan", JSON.parse(event.data || "{}"));
        });

        source.addEventListener("result", (event) => {
          consumeEvent("result", JSON.parse(event.data || "{}"));
        });

        source.addEventListener("error", (event) => {
          try {
            consumeEvent("error", JSON.parse(event.data || "{}"));
          } catch (error) {
            showToast("串流失敗");
          }
        });

        source.addEventListener("done", async (event) => {
          const data = JSON.parse(event.data || "{}");
          applySessionFromEvent(data);
          source.close();
          finalizeAssistantBubble();
          setStreaming(false);
          await loadProjects();
          if (state.projectId) {
            await loadContext();
          }
        });
      }

      function renderAttachmentPreview() {
        elements.attachmentPreview.innerHTML = "";
        if (!state.attachments || state.attachments.length === 0) return;
        state.attachments.forEach((file) => {
          const item = document.createElement("div");
          item.className = "attachment-item";
          const info = document.createElement("div");
          info.className = "attachment-info";
          info.textContent = `${file.name} (${Math.round(file.size / 1024)} KB)`;
          if (file.type.startsWith("image/")) {
            const img = document.createElement("img");
            img.alt = file.name;
            img.src = URL.createObjectURL(file);
            img.onload = () => URL.revokeObjectURL(img.src);
            item.appendChild(img);
          } else if (file.type.startsWith("video/")) {
            const video = document.createElement("video");
            video.src = URL.createObjectURL(file);
            video.controls = true;
            video.onloadeddata = () => URL.revokeObjectURL(video.src);
            item.appendChild(video);
          } else if (file.type === "application/pdf") {
            const embed = document.createElement("embed");
            embed.src = URL.createObjectURL(file);
            embed.type = "application/pdf";
            embed.onload = () => URL.revokeObjectURL(embed.src);
            item.appendChild(embed);
          }
          item.appendChild(info);
          elements.attachmentPreview.appendChild(item);
        });
      }

      elements.chatForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const message = elements.chatInput.value.trim();
        if (!message) return;
        const attachments = [...state.attachments];
        elements.chatInput.value = "";
        elements.chatAttachments.value = "";
        state.attachments = [];
        renderAttachmentPreview();
        startStream(message, attachments);
      });

      elements.projectSelect.addEventListener("change", async (event) => {
        const selectedProject = event.target.value;
        setProjectState(selectedProject);
        if (state.projectId) {
          await ensureChatSession();
          await loadContext();
        }
      });

      elements.refreshContext.addEventListener("click", loadContext);
      elements.planConfirm.addEventListener("click", () => confirmPlan(true));
      elements.planCancel.addEventListener("click", () => confirmPlan(false));
      elements.chatAttachments.addEventListener("change", (event) => {
        state.attachments = Array.from(event.target.files || []);
        renderAttachmentPreview();
      });
      elements.contextTabs.forEach((tab) => {
        tab.addEventListener("click", () => switchContextTab(tab.dataset.contextTab));
      });

      elements.thinkingMode.addEventListener("change", (event) => {
        state.thinkingMode = event.target.value;
        updateThinking({ status: "idle", brief: "已切換 Thinking 顯示模式" });
      });

      (async () => {
        try {
          await loadProjects();
          setProjectState(state.projectId);
          renderArtifacts([]);
          updateThinking({ status: "idle", brief: "目前沒有 Thinking 事件" });
          if (state.projectId) {
            await ensureChatSession();
            await loadContext();
          }
        } catch (error) {
          showToast(`初始化失敗：${error.message}`);
        }
      })();
    </script>
  </body>
</html>
