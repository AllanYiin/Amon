<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Amon｜Chat UI</title>
    <link rel="stylesheet" href="styles.css" />
    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
      mermaid.initialize({ startOnLoad: false, theme: "neutral" });
      window.__mermaid = mermaid;
    </script>
  </head>
  <body>
    <main class="page">
      <div class="ui-shell" id="ui-shell">
        <aside class="shell-sidebar" aria-label="主要導覽">
          <h2>Amon UI</h2>
          <nav class="shell-nav">
            <button type="button" class="shell-nav__item is-active">Chat</button>
            <button type="button" class="shell-nav__item">Context</button>
            <button type="button" class="shell-nav__item">Graph</button>
            <button type="button" class="shell-nav__item">Tools &amp; Skills</button>
            <button type="button" class="shell-nav__item">Config</button>
            <button type="button" class="shell-nav__item">Logs &amp; Events</button>
            <button type="button" class="shell-nav__item">Docs</button>
            <button type="button" class="shell-nav__item">Bill</button>
          </nav>
        </aside>

        <section class="shell-main">
          <header class="shell-topbar" aria-label="工作列">
            <div class="shell-topbar__group">
              <label class="field-label shell-topbar__field">
                Project
                <select id="shell-project-select">
                  <option>Demo 專案（假資料）</option>
                  <option>Internal Playground（假資料）</option>
                </select>
              </label>
              <span class="shell-status shell-status--run" id="shell-run-status">Run：Idle</span>
              <span class="shell-status shell-status--daemon" id="shell-daemon-status">Daemon：Healthy</span>
              <span class="shell-status shell-status--budget" id="shell-budget-status">Budget：NT$ 0 / NT$ 5,000</span>
            </div>
            <button type="button" class="secondary-btn shell-context-toggle" id="toggle-context-panel" aria-expanded="true">收合右側面板</button>
          </header>

          <div class="layout chat-layout" id="chat-layout">
            <section class="main-card chat-panel">
          <header class="chat-header">
            <div>
              <h1>Amon Chat</h1>
              <p class="subtitle">請用自然語言操作專案與任務（支援 streaming）。</p>
            </div>
            <div class="chat-controls">
              <label class="field-label">
                專案
                <select id="project-select"></select>
              </label>
              <button class="secondary-btn" id="refresh-context">刷新 Context</button>
            </div>
          </header>

          <section id="timeline" class="chat-timeline"></section>

          <div class="progress-bar" id="stream-progress" aria-hidden="true">
            <span></span>
          </div>

          <section id="plan-card" class="plan-card" hidden>
            <div class="plan-card__header">
              <h3>Plan Card</h3>
              <p>此操作需要確認才能繼續。</p>
            </div>
            <pre id="plan-content"></pre>
            <div class="plan-card__actions">
              <button class="secondary-btn" id="plan-cancel">取消</button>
              <button class="primary-btn" id="plan-confirm">確認執行</button>
            </div>
          </section>

          <form id="chat-form" class="chat-input">
            <div class="chat-input__main">
              <textarea id="chat-input" rows="4" placeholder="輸入你的需求，例如：建立專案 Amon Demo"></textarea>
              <div class="chat-input__toolbar">
                <label class="file-btn">
                  加入附件
                  <input id="chat-attachments" type="file" multiple accept="image/*,video/*,.pdf" />
                </label>
                <span class="chat-input__hint">支援圖片、PDF、影片；附件會以文字摘要送出。</span>
              </div>
              <div id="attachment-preview" class="attachment-preview"></div>
            </div>
            <button type="submit" class="primary-btn">送出</button>
          </form>
        </section>

            <aside class="context-panel" id="context-panel">
          <h2>右側資訊</h2>
          <div class="context-shell-placeholders" aria-label="右側狀態摘要">
            <div class="context-shell-card">
              <p class="context-shell-card__label">Memory Used</p>
              <strong id="card-memory-used">--</strong>
            </div>
            <div class="context-shell-card">
              <p class="context-shell-card__label">Run Progress</p>
              <strong id="card-run-progress">--</strong>
            </div>
            <div class="context-shell-card">
              <p class="context-shell-card__label">Billing</p>
              <strong id="card-billing">--</strong>
            </div>
            <div class="context-shell-card">
              <p class="context-shell-card__label">Pending Confirmations</p>
              <strong id="card-pending-confirmations">--</strong>
            </div>
          </div>
          <div class="context-project" id="context-project">目前專案：未選擇</div>
          <div class="context-tabs" role="tablist" aria-label="右側資訊切換">
            <button type="button" class="context-tab is-active" data-context-tab="context" role="tab" aria-selected="true">Context</button>
            <button type="button" class="context-tab" data-context-tab="graph" role="tab" aria-selected="false">Graph</button>
            <button type="button" class="context-tab" data-context-tab="docs" role="tab" aria-selected="false">Docs</button>
          </div>

          <section class="context-section" data-context-panel="context">
            <h3>Context</h3>
            <p id="context-overview" class="context-overview">請先在上方選擇專案，右側內容會自動同步。</p>
          </section>
          <section class="context-section" data-context-panel="graph" hidden>
            <h3>Graph Preview</h3>
            <div class="graph-toolbar">
              <span id="graph-run-meta" class="graph-run-meta">尚未偵測到 run</span>
              <div class="graph-toolbar__actions">
                <button type="button" class="secondary-btn" id="graph-create-template">Create template</button>
              </div>
            </div>
            <div id="graph-preview" class="graph-preview"></div>
            <ul id="graph-node-list" class="graph-node-list"></ul>
            <pre id="graph-code" class="graph-code"></pre>
          </section>
          <section class="context-section" data-context-panel="docs" hidden>
            <h3>Docs</h3>
            <ul id="docs-list" class="docs-list"></ul>
          </section>
            </aside>
          </div>
        </section>
      </div>
    </main>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
    <aside id="graph-node-drawer" class="graph-node-drawer" hidden>
      <header class="graph-node-drawer__header">
        <h3 id="graph-node-title">Node 詳細</h3>
        <button type="button" class="secondary-btn" id="graph-node-close">關閉</button>
      </header>
      <div class="graph-node-drawer__meta" id="graph-node-meta"></div>
      <section>
        <h4>inputs</h4>
        <details open>
          <summary>展開內容</summary>
          <pre id="graph-node-inputs" class="graph-node-json"></pre>
        </details>
      </section>
      <section>
        <h4>outputs（docs/artifacts）</h4>
        <pre id="graph-node-outputs" class="graph-node-json"></pre>
      </section>
      <section>
        <h4>最近 events/logs</h4>
        <ul id="graph-node-events" class="graph-node-events"></ul>
      </section>
      <section>
        <h4>Template 化</h4>
        <div class="graph-node-drawer__actions">
          <button type="button" class="secondary-btn" id="graph-parametrize">Parametrize（改成 {{var}}）</button>
        </div>
      </section>
    </aside>

    <script src="/event_stream_client.js"></script>
    <script>
      const { EventStreamClient, createUiEventStore, defaultMockFactory } = window.AmonUIEventStream;
      const state = {
        chatId: null,
        projectId: null,
        plan: null,
        streaming: false,
        attachments: [],
        uiStore: createUiEventStore(),
        streamClient: null,
        graph: null,
        graphRunId: null,
        graphNodeStates: {},
        graphEvents: [],
        graphSelectedNodeId: null,
        graphTemplateId: null,
      };

      const elements = {
        projectSelect: document.getElementById("project-select"),
        timeline: document.getElementById("timeline"),
        chatForm: document.getElementById("chat-form"),
        chatInput: document.getElementById("chat-input"),
        chatAttachments: document.getElementById("chat-attachments"),
        attachmentPreview: document.getElementById("attachment-preview"),
        toast: document.getElementById("toast"),
        planCard: document.getElementById("plan-card"),
        planContent: document.getElementById("plan-content"),
        planConfirm: document.getElementById("plan-confirm"),
        planCancel: document.getElementById("plan-cancel"),
        refreshContext: document.getElementById("refresh-context"),
        graphPreview: document.getElementById("graph-preview"),
        graphCode: document.getElementById("graph-code"),
        graphNodeList: document.getElementById("graph-node-list"),
        graphRunMeta: document.getElementById("graph-run-meta"),
        graphCreateTemplate: document.getElementById("graph-create-template"),
        graphNodeDrawer: document.getElementById("graph-node-drawer"),
        graphNodeClose: document.getElementById("graph-node-close"),
        graphNodeTitle: document.getElementById("graph-node-title"),
        graphNodeMeta: document.getElementById("graph-node-meta"),
        graphNodeInputs: document.getElementById("graph-node-inputs"),
        graphNodeOutputs: document.getElementById("graph-node-outputs"),
        graphNodeEvents: document.getElementById("graph-node-events"),
        graphParametrize: document.getElementById("graph-parametrize"),
        docsList: document.getElementById("docs-list"),
        contextProject: document.getElementById("context-project"),
        contextOverview: document.getElementById("context-overview"),
        contextTabs: document.querySelectorAll(".context-tab"),
        contextPanels: document.querySelectorAll("[data-context-panel]"),
        streamProgress: document.getElementById("stream-progress"),
        uiShell: document.getElementById("ui-shell"),
        toggleContextPanel: document.getElementById("toggle-context-panel"),
        shellRunStatus: document.getElementById("shell-run-status"),
        shellDaemonStatus: document.getElementById("shell-daemon-status"),
        shellBudgetStatus: document.getElementById("shell-budget-status"),
        cardRunProgress: document.getElementById("card-run-progress"),
        cardBilling: document.getElementById("card-billing"),
        cardPendingConfirmations: document.getElementById("card-pending-confirmations"),
      };

      function syncContextPanelToggle() {
        if (!elements.uiShell || !elements.toggleContextPanel) {
          return;
        }
        const collapsed = elements.uiShell.classList.contains("is-context-collapsed");
        elements.toggleContextPanel.textContent = collapsed ? "展開右側面板" : "收合右側面板";
        elements.toggleContextPanel.setAttribute("aria-expanded", String(!collapsed));
      }

      elements.toggleContextPanel?.addEventListener("click", () => {
        elements.uiShell?.classList.toggle("is-context-collapsed");
        syncContextPanelToggle();
      });

      syncContextPanelToggle();

      function showToast(message) {
        elements.toast.textContent = message;
        elements.toast.classList.add("visible");
        window.clearTimeout(elements.toast._timer);
        elements.toast._timer = window.setTimeout(() => {
          elements.toast.classList.remove("visible");
        }, 9000);
      }

      function isMockModeEnabled() {
        const params = new URLSearchParams(window.location.search);
        if (params.get("mock_stream") === "1") {
          return true;
        }
        return window.localStorage.getItem("amon.ui.mock_stream") === "1";
      }

      function renderStoreSummary(storeState) {
        const runStatus = storeState.run?.status || (state.streaming ? "streaming" : "idle");
        const runProgress = storeState.run?.progress;
        elements.shellRunStatus.textContent = `Run：${runStatus}`;
        elements.cardRunProgress.textContent = Number.isFinite(runProgress) ? `${runProgress}%` : "--";
        elements.cardBilling.textContent = `NT$ ${storeState.billing.total_cost.toFixed(2)}`;
        elements.shellBudgetStatus.textContent = `Budget：NT$ ${storeState.billing.total_cost.toFixed(2)} / NT$ 5,000`;
        const pendingJobs = Object.values(storeState.jobs).filter((job) => job.status && job.status !== "completed").length;
        elements.cardPendingConfirmations.textContent = pendingJobs > 0 ? `${pendingJobs} 項任務進行中` : "0";
      }

      state.uiStore.subscribe((snapshot) => {
        renderStoreSummary(snapshot);
        if (snapshot.docs.length > 0) {
          renderDocs(snapshot.docs);
        }
      });
      renderStoreSummary(state.uiStore.getState());

      async function apiFetch(path, options = {}) {
        const response = await fetch(`/v1${path}`, {
          headers: { "Content-Type": "application/json" },
          ...options,
        });
        let payload = {};
        try {
          payload = await response.json();
        } catch (error) {
          payload = {};
        }
        if (!response.ok) {
          throw new Error(payload.message || "API 發生錯誤");
        }
        return payload;
      }

      function appendMessage(role, text) {
        const bubble = document.createElement("div");
        bubble.className = `chat-bubble ${role}`;
        bubble.innerHTML = renderMarkdown(text);
        elements.timeline.appendChild(bubble);
        elements.timeline.scrollTop = elements.timeline.scrollHeight;
        return bubble;
      }

      function escapeHtml(text) {
        return text
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function renderInlineMarkdown(text) {
        let html = escapeHtml(text);
        html = html.replace(/`([^`]+)`/g, "<code>$1</code>");
        html = html.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        html = html.replace(/\*([^*]+)\*/g, "<em>$1</em>");
        html = html.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
        return html;
      }

      function renderMarkdown(text) {
        const lines = String(text || "").split("\n");
        const html = [];
        let inList = false;
        let inCodeBlock = false;
        let codeLines = [];
        let paragraph = [];

        const flushParagraph = () => {
          if (!paragraph.length) return;
          html.push(`<p>${renderInlineMarkdown(paragraph.join("\n")).replaceAll("\n", "<br />")}</p>`);
          paragraph = [];
        };

        const flushCodeBlock = () => {
          if (!inCodeBlock) return;
          html.push(`<pre><code>${escapeHtml(codeLines.join("\n"))}</code></pre>`);
          inCodeBlock = false;
          codeLines = [];
        };

        const closeList = () => {
          if (!inList) return;
          html.push("</ul>");
          inList = false;
        };

        lines.forEach((rawLine) => {
          const line = rawLine.trimEnd();
          if (line.trim().startsWith("```")) {
            flushParagraph();
            closeList();
            if (inCodeBlock) {
              flushCodeBlock();
            } else {
              inCodeBlock = true;
              codeLines = [];
            }
            return;
          }

          if (inCodeBlock) {
            codeLines.push(rawLine);
            return;
          }

          if (!line.trim()) {
            flushParagraph();
            closeList();
            return;
          }

          const headingMatch = line.match(/^(#{1,3})\s+(.+)$/);
          if (headingMatch) {
            flushParagraph();
            closeList();
            const level = headingMatch[1].length;
            html.push(`<h${level}>${renderInlineMarkdown(headingMatch[2])}</h${level}>`);
            return;
          }

          const listMatch = line.match(/^[-*]\s+(.+)$/);
          if (listMatch) {
            flushParagraph();
            if (!inList) {
              html.push("<ul>");
              inList = true;
            }
            html.push(`<li>${renderInlineMarkdown(listMatch[1])}</li>`);
            return;
          }

          closeList();
          paragraph.push(line);
        });

        flushParagraph();
        closeList();
        flushCodeBlock();
        return html.join("");
      }

      function setStreaming(active) {
        state.streaming = active;
        elements.streamProgress.hidden = !active;
        elements.chatInput.disabled = active;
      }

      function resetPlanCard() {
        state.plan = null;
        elements.planCard.hidden = true;
        elements.planContent.textContent = "";
      }

      function setProjectState(projectId) {
        state.projectId = projectId || null;
        elements.refreshContext.disabled = !state.projectId;
        elements.projectSelect.value = projectId || "";
        syncContextHeader();
        if (!state.projectId) {
          state.chatId = null;
          elements.graphPreview.innerHTML = "<p class=\"empty-context\">請先在上方選擇專案。</p>";
          elements.graphCode.textContent = "";
          elements.contextOverview.textContent = "請先在上方選擇專案，右側內容會自動同步。";
          renderDocs([]);
        }
      }

      function syncContextHeader() {
        const selected = elements.projectSelect.selectedOptions[0]?.textContent || "未選擇";
        elements.contextProject.textContent = `目前專案：${selected}`;
      }

      function switchContextTab(tabName) {
        elements.contextTabs.forEach((tab) => {
          const isActive = tab.dataset.contextTab === tabName;
          tab.classList.toggle("is-active", isActive);
          tab.setAttribute("aria-selected", String(isActive));
        });
        elements.contextPanels.forEach((panel) => {
          panel.hidden = panel.dataset.contextPanel !== tabName;
        });
      }

      async function loadProjects() {
        const payload = await apiFetch("/projects");
        const projects = payload.projects || [];
        elements.projectSelect.innerHTML = "";
        const emptyOption = document.createElement("option");
        emptyOption.value = "";
        emptyOption.textContent = "不指定專案";
        elements.projectSelect.appendChild(emptyOption);
        projects.forEach((project) => {
          const option = document.createElement("option");
          option.value = project.project_id;
          option.textContent = `${project.name}（${project.project_id}）`;
          elements.projectSelect.appendChild(option);
        });
        const availableIds = new Set(projects.map((project) => project.project_id));
        if (state.projectId && !availableIds.has(state.projectId)) {
          state.projectId = null;
        }
        elements.projectSelect.value = state.projectId || "";
        syncContextHeader();
        if (!projects.length) {
          showToast("尚無專案，請在聊天輸入：建立專案 <名稱>");
        }
        elements.refreshContext.disabled = !state.projectId;
      }

      async function ensureChatSession() {
        if (!state.projectId) return;
        const payload = await apiFetch("/chat/sessions", {
          method: "POST",
          body: JSON.stringify({ project_id: state.projectId }),
        });
        state.chatId = payload.chat_id;
      }

      async function loadContext() {
        if (!state.projectId) {
          showToast("請先選擇專案。");
          return;
        }
        const payload = await apiFetch(`/projects/${state.projectId}/context`);
        state.graph = payload.graph || { nodes: [], edges: [] };
        state.graphRunId = payload.run_id || null;
        state.graphNodeStates = payload.node_states || {};
        state.graphEvents = payload.recent_events || [];
        elements.graphCode.textContent = payload.graph_mermaid || "";
        renderGraph(payload.graph_mermaid || "");
        renderNodeList();
        elements.graphRunMeta.textContent = state.graphRunId
          ? `Run：${state.graphRunId}（${payload.run_status || "unknown"}）`
          : "尚未偵測到 run";
        renderDocs(payload.docs || []);
        const docCount = (payload.docs || []).length;
        const hasGraph = payload.graph_mermaid ? "有" : "無";
        elements.contextOverview.textContent = `已同步專案內容：Graph ${hasGraph}、文件 ${docCount} 筆。`;
      }

      function renderDocs(docs) {
        elements.docsList.innerHTML = "";
        if (!docs.length) {
          const item = document.createElement("li");
          item.textContent = state.projectId ? "尚無文件" : "請先選擇專案";
          elements.docsList.appendChild(item);
          return;
        }
        docs.forEach((doc) => {
          const item = document.createElement("li");
          item.textContent = doc;
          elements.docsList.appendChild(item);
        });
      }

      async function renderGraph(code) {
        elements.graphPreview.innerHTML = "";
        if (!code) return;
        try {
          const { svg } = await window.__mermaid.render(`graphPreview-${Date.now()}`, code);
          elements.graphPreview.innerHTML = svg;
          decorateMermaidNodes();
        } catch (error) {
          elements.graphPreview.innerHTML = "<p>Mermaid 渲染失敗，請檢查 graph。</p>";
        }
      }

      function normalizeNodeStatus(status) {
        if (status === "completed") return "succeeded";
        if (["pending", "running", "failed", "succeeded"].includes(status)) return status;
        return "pending";
      }

      function getNodeState(nodeId) {
        return state.graphNodeStates?.[nodeId] || { status: "pending" };
      }

      function nodeStatusLabel(status) {
        const normalized = normalizeNodeStatus(status);
        if (normalized === "running") return "執行中";
        if (normalized === "succeeded") return "成功";
        if (normalized === "failed") return "失敗";
        return "等待中";
      }

      function renderNodeList() {
        elements.graphNodeList.innerHTML = "";
        const nodes = state.graph?.nodes || [];
        if (!nodes.length) return;
        nodes.forEach((node) => {
          const stateItem = getNodeState(node.id);
          const status = normalizeNodeStatus(stateItem.status);
          const item = document.createElement("li");
          item.className = "graph-node-item";
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "graph-node-item__button";
          btn.innerHTML = `<span>${node.id}</span><span class="node-status node-status--${status}">${nodeStatusLabel(status)}</span>`;
          btn.addEventListener("click", () => openNodeDrawer(node.id));
          item.appendChild(btn);
          elements.graphNodeList.appendChild(item);
        });
      }

      function decorateMermaidNodes() {
        const groups = elements.graphPreview.querySelectorAll("g.node");
        groups.forEach((group) => {
          const label = group.querySelector(".nodeLabel")?.textContent?.trim();
          if (!label) return;
          const status = normalizeNodeStatus(getNodeState(label).status);
          group.classList.add(`node-status--${status}`);
          group.style.cursor = "pointer";
          group.addEventListener("click", () => openNodeDrawer(label));
        });
      }

      function inferNodeInputs(node) {
        const payload = {};
        ["args", "input", "inputs", "prompt", "content", "tool"].forEach((key) => {
          if (node[key] !== undefined) payload[key] = node[key];
        });
        return payload;
      }

      function extractOutputArtifacts(output) {
        if (!output || typeof output !== "object") return { docs: [], artifacts: [], raw: output };
        return {
          docs: output.docs || output.documents || [],
          artifacts: output.artifacts || output.files || [],
          raw: output,
        };
      }

      function openNodeDrawer(nodeId) {
        const node = (state.graph?.nodes || []).find((item) => item.id === nodeId);
        if (!node) return;
        state.graphSelectedNodeId = nodeId;
        const nodeState = getNodeState(nodeId);
        const executionEngine = node.type && String(node.type).includes("tool") ? "tool" : "llm";
        elements.graphNodeTitle.textContent = `Node：${nodeId}`;
        elements.graphNodeMeta.textContent = `status：${nodeStatusLabel(nodeState.status)} ｜ execution_engine：${executionEngine}`;
        elements.graphNodeInputs.textContent = JSON.stringify(inferNodeInputs(node), null, 2);
        elements.graphNodeOutputs.textContent = JSON.stringify(extractOutputArtifacts(nodeState.output), null, 2);
        elements.graphNodeEvents.innerHTML = "";
        state.graphEvents
          .filter((event) => event.node_id === nodeId || event.from === nodeId || event.to === nodeId)
          .slice(-8)
          .forEach((event) => {
            const item = document.createElement("li");
            item.textContent = JSON.stringify(event);
            elements.graphNodeEvents.appendChild(item);
          });
        if (!elements.graphNodeEvents.children.length) {
          const item = document.createElement("li");
          item.textContent = "尚無 events/logs";
          elements.graphNodeEvents.appendChild(item);
        }
        elements.graphNodeDrawer.hidden = false;
      }

      function closeNodeDrawer() {
        elements.graphNodeDrawer.hidden = true;
      }

      function queuePlanCommand(command, args, description) {
        showPlanCard({
          command,
          args,
          plan_card: `${description}\n\ncommand: ${command}\nargs: ${JSON.stringify(args, null, 2)}`,
        });
      }

      function showPlanCard(plan) {
        state.plan = plan;
        elements.planContent.textContent = plan.plan_card || "";
        elements.planCard.hidden = false;
      }

      function applySessionFromEvent(data) {
        if (!data) return;
        if (data.project_id && data.project_id !== state.projectId) {
          setProjectState(data.project_id);
        }
        if (data.chat_id) {
          state.chatId = data.chat_id;
        }
      }

      async function confirmPlan(confirmed) {
        if (!state.plan) return;
        try {
          const payload = await apiFetch("/chat/plan/confirm", {
            method: "POST",
            body: JSON.stringify({
              project_id: state.projectId,
              chat_id: state.chatId,
              command: state.plan.command,
              args: state.plan.args || {},
              confirmed,
            }),
          });
          appendMessage("agent", confirmed ? "已確認執行。" : "已取消執行。");
          if (confirmed && state.plan?.command === "graph.template.create") {
            state.graphTemplateId = payload.result?.template_id || state.graphTemplateId;
            if (state.graphTemplateId) {
              showToast(`Template 已建立：${state.graphTemplateId}`);
            }
          }
          resetPlanCard();
          if (state.projectId) {
            await loadContext();
          }
        } catch (error) {
          showToast(`Plan 執行失敗：${error.message}`);
        }
      }

      function buildAttachmentSummary(attachments) {
        if (!attachments || attachments.length === 0) return "";
        const lines = attachments.map((file) => {
          const sizeKb = Math.round(file.size / 1024);
          return `- ${file.name} (${file.type || "未知格式"}, ${sizeKb} KB)`;
        });
        return `\n\n[附件摘要]\n${lines.join("\n")}`;
      }

      function startStream(message, attachments = []) {
        resetPlanCard();
        const finalMessage = `${message}${buildAttachmentSummary(attachments)}`;
        appendMessage("user", `你：${finalMessage}`);
        const agentBubble = appendMessage("agent", "Amon：");
        setStreaming(true);
        let buffer = "";

        if (state.streamClient) {
          state.streamClient.stop();
          state.streamClient = null;
        }

        state.streamClient = new EventStreamClient({
          preferSSE: true,
          useMock: isMockModeEnabled(),
          sseUrlBuilder: (params, lastEventId) => {
            const query = new URLSearchParams({ message: params.message });
            if (params.project_id) query.set("project_id", params.project_id);
            if (params.chat_id) query.set("chat_id", params.chat_id);
            if (lastEventId) query.set("last_event_id", lastEventId);
            return `/v1/chat/stream?${query.toString()}`;
          },
          wsUrlBuilder: (params, lastEventId) => {
            const protocol = window.location.protocol === "https:" ? "wss" : "ws";
            const query = new URLSearchParams({ message: params.message });
            if (params.project_id) query.set("project_id", params.project_id);
            if (params.chat_id) query.set("chat_id", params.chat_id);
            if (lastEventId) query.set("last_event_id", lastEventId);
            return `${protocol}://${window.location.host}/v1/chat/ws?${query.toString()}`;
          },
          mockFactory: defaultMockFactory,
          onStatusChange: ({ status, transport }) => {
            if (status === "connected") {
              const mode = transport === "mock" ? "Mock" : "Healthy";
              elements.shellDaemonStatus.textContent = `Daemon：${mode}`;
            }
            if (status === "reconnecting") {
              elements.shellDaemonStatus.textContent = "Daemon：Reconnecting";
              showToast(`串流中斷，正在重新連線（${transport || "unknown"}）`);
            }
            if (status === "error") {
              elements.shellDaemonStatus.textContent = "Daemon：Unavailable";
            }
          },
          onEvent: async (eventType, data) => {
            state.uiStore.applyEvent(eventType, data);
            if (state.projectId && ["result", "done", "notice"].includes(eventType)) {
              await loadContext();
            }
            if (eventType === "token") {
              buffer += data.text || "";
              agentBubble.innerHTML = renderMarkdown(`Amon：${buffer}`);
              elements.timeline.scrollTop = elements.timeline.scrollHeight;
              return;
            }
            if (eventType === "notice") {
              if (data.text) appendMessage("agent", data.text);
              return;
            }
            if (eventType === "plan") {
              applySessionFromEvent(data);
              showPlanCard(data);
              agentBubble.innerHTML = renderMarkdown("Amon：已產生 Plan Card，請確認。");
              return;
            }
            if (eventType === "result") {
              agentBubble.innerHTML = renderMarkdown(`Amon：\n\n\`\`\`json\n${JSON.stringify(data, null, 2)}\n\`\`\``);
              return;
            }
            if (eventType === "error") {
              showToast(data.message || "串流失敗");
              return;
            }
            if (eventType === "done") {
              applySessionFromEvent(data);
              state.streamClient?.stop();
              state.streamClient = null;
              setStreaming(false);
              await loadProjects();
              if (state.projectId) {
                await loadContext();
              }
            }
          },
        });

        state.streamClient.start({
          message: finalMessage,
          project_id: state.projectId,
          chat_id: state.chatId,
        });
      }

      function renderAttachmentPreview() {
        elements.attachmentPreview.innerHTML = "";
        if (!state.attachments || state.attachments.length === 0) return;
        state.attachments.forEach((file) => {
          const item = document.createElement("div");
          item.className = "attachment-item";
          const info = document.createElement("div");
          info.className = "attachment-info";
          info.textContent = `${file.name} (${Math.round(file.size / 1024)} KB)`;
          if (file.type.startsWith("image/")) {
            const img = document.createElement("img");
            img.alt = file.name;
            img.src = URL.createObjectURL(file);
            img.onload = () => URL.revokeObjectURL(img.src);
            item.appendChild(img);
          } else if (file.type.startsWith("video/")) {
            const video = document.createElement("video");
            video.src = URL.createObjectURL(file);
            video.controls = true;
            video.onloadeddata = () => URL.revokeObjectURL(video.src);
            item.appendChild(video);
          } else if (file.type === "application/pdf") {
            const embed = document.createElement("embed");
            embed.src = URL.createObjectURL(file);
            embed.type = "application/pdf";
            embed.onload = () => URL.revokeObjectURL(embed.src);
            item.appendChild(embed);
          }
          item.appendChild(info);
          elements.attachmentPreview.appendChild(item);
        });
      }

      elements.chatForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const message = elements.chatInput.value.trim();
        if (!message) return;
        const attachments = [...state.attachments];
        elements.chatInput.value = "";
        elements.chatAttachments.value = "";
        state.attachments = [];
        renderAttachmentPreview();
        startStream(message, attachments);
      });

      elements.projectSelect.addEventListener("change", async (event) => {
        const selectedProject = event.target.value;
        setProjectState(selectedProject);
        if (state.projectId) {
          await ensureChatSession();
          await loadContext();
        }
      });

      elements.refreshContext.addEventListener("click", loadContext);
      elements.planConfirm.addEventListener("click", () => confirmPlan(true));
      elements.planCancel.addEventListener("click", () => confirmPlan(false));
      elements.graphNodeClose.addEventListener("click", closeNodeDrawer);
      elements.graphCreateTemplate.addEventListener("click", () => {
        if (!state.projectId || !state.graphRunId) {
          showToast("需要先有 run 才能建立 template。");
          return;
        }
        queuePlanCommand(
          "graph.template.create",
          { project_id: state.projectId, run_id: state.graphRunId, name: `${state.projectId}-${state.graphRunId}` },
          "建立 graph template（需確認）"
        );
      });
      elements.graphParametrize.addEventListener("click", () => {
        if (!state.graphTemplateId) {
          showToast("請先 Create template。\n此操作需要 Plan Card。");
          return;
        }
        if (!state.graphSelectedNodeId) {
          showToast("請先選擇 node。");
          return;
        }
        const varName = window.prompt("請輸入變數名稱（例如 customer_name）", "var");
        if (!varName) return;
        const jsonPath = window.prompt("請輸入 JSONPath（例如 $.nodes[0].args.prompt）", "");
        if (!jsonPath) return;
        queuePlanCommand(
          "graph.template.parametrize",
          { template_id: state.graphTemplateId, jsonpath: jsonPath, var_name: varName },
          `參數化 template（需確認）\nnode: ${state.graphSelectedNodeId}`
        );
      });
      elements.chatAttachments.addEventListener("change", (event) => {
        state.attachments = Array.from(event.target.files || []);
        renderAttachmentPreview();
      });
      elements.contextTabs.forEach((tab) => {
        tab.addEventListener("click", () => switchContextTab(tab.dataset.contextTab));
      });

      (async () => {
        try {
          await loadProjects();
          setProjectState(state.projectId);
          if (state.projectId) {
            await ensureChatSession();
            await loadContext();
          }
        } catch (error) {
          showToast(`初始化失敗：${error.message}`);
        }
      })();
    </script>
  </body>
</html>
